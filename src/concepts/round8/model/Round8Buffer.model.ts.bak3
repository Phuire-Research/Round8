/**
 * Round8Buffer Model File - Internal Buffer Operations
 *
 * Pure Round8 paradigm using Rotations (3 positions), Cycles (6 positions),
 * and Columnar Stacking (regular array access) - NOT traditional byte/bit operations.
 *
 * 64-Position Structure:
 *   - Position 0: Sign (0=negative trajectory, 1=positive trajectory)
 *   - Positions 1-63: Magnitude (21 rotations)
 *
 * Rotation Structure:
 *   - 21 rotations total (each rotation = 3 positions)
 *   - 10 cycles (each cycle = 2 rotations = 6 positions)
 *   - 1 single rotation (positions 61-63)
 *
 * Inverted Sign Convention:
 *   - Sign=0: Negative trajectory (spatial backward/down/left)
 *   - Sign=1: Positive trajectory (spatial forward/up/right)
 *
 * @module Round8Buffer
 * @internal
 */

/**
 * Round8 Position and Rotation Constants
 */
const SIGN_POSITION = 0;
const MAGNITUDE_START = 1;
const MAGNITUDE_END = 63;
const TOTAL_POSITIONS = 64;
const POSITIONS_PER_ROTATION = 3;
const TOTAL_ROTATIONS = 21;
const POSITIONS_PER_CYCLE = 6;
const TOTAL_CYCLES = 10;
const SINGLE_ROTATION_INDEX = 20;

/**
 * Base-72 Cycle Values (using BigInt for precision)
 */
const CYCLE_VALUES = [
  72n ** 0n,   // Cycle 0: 1
  72n ** 1n,   // Cycle 1: 72
  72n ** 2n,   // Cycle 2: 5,184
  72n ** 3n,   // Cycle 3: 373,248
  72n ** 4n,   // Cycle 4: 26,873,856
  72n ** 5n,   // Cycle 5: 1,934,917,632
  72n ** 6n,   // Cycle 6: 139,314,069,504
  72n ** 7n,   // Cycle 7: 10,030,613,004,288
  72n ** 8n,   // Cycle 8: 722,204,136,308,736
  72n ** 9n,   // Cycle 9: 51,998,697,814,228,992
  72n ** 10n,  // Single rotation 20: 3,743,906,242,624,487,424
];

/**
 * Error codes for Round8 operations
 */
export enum Round8ErrorCode {
  INVALID_DIGIT = 'INVALID_DIGIT',
  INVALID_STRING = 'INVALID_STRING',
  DIVISION_BY_ZERO = 'DIVISION_BY_ZERO',
  NEGATIVE_ONE_ARITHMETIC = 'NEGATIVE_ONE_ARITHMETIC',
  OUT_OF_SAFE_INTEGER_RANGE = 'OUT_OF_SAFE_INTEGER_RANGE',
  BUFFER_OVERFLOW = 'BUFFER_OVERFLOW',
  RESERVED_PATTERN_VIOLATION = 'RESERVED_PATTERN_VIOLATION',
}

/**
 * Round8Error - Custom error type
 */
export class Round8Error extends Error {
  readonly code: Round8ErrorCode;
  readonly context?: unknown;

  constructor(code: Round8ErrorCode, message: string, context?: unknown) {
    super(message);
    this.name = 'Round8Error';
    this.code = code;
    this.context = context;
  }
}

/**
 * Get rotation number from magnitude position
 * @param magnitudePos - Position 1-63
 * @returns Rotation number 0-20
 */
function getRotationNumber(magnitudePos: number): number {
  return Math.floor((magnitudePos - 1) / POSITIONS_PER_ROTATION);
}

/**
 * Get starting position for a rotation
 * @param rotationNum - 0-20
 * @returns Starting position (1, 4, 7, ..., 61)
 */
function getRotationStartPosition(rotationNum: number): number {
  return 1 + (rotationNum * POSITIONS_PER_ROTATION);
}

/**
 * Round8Buffer - 64-position native array (Pure Round8 Paradigm)
 *
 * Position 0: Sign
 * Positions 1-63: Magnitude (21 rotations)
 *
 * Uses Uint8Array where each element holds 0 or 1 (single bit).
 * This represents columnar stacking - direct array access, no byte boundaries.
 */
export class Round8Buffer {
  private positions: Uint8Array;

  constructor(positions?: Uint8Array) {
    if (positions) {
      if (positions.length !== TOTAL_POSITIONS) {
        throw new Round8Error(
          Round8ErrorCode.INVALID_STRING,
          `Round8Buffer requires exactly ${TOTAL_POSITIONS} positions, got ${positions.length}`
        );
      }
      this.positions = positions;
    } else {
      // Initialize all positions to 0
      this.positions = new Uint8Array(TOTAL_POSITIONS);
    }
  }

  /**
   * Get direct access to position array
   */
  getPositions(): Uint8Array {
    return this.positions;
  }

  /**
   * Clone buffer (independent copy for immutable operations)
   */
  clone(): Round8Buffer {
    const newPositions = new Uint8Array(TOTAL_POSITIONS);
    for (let i = 0; i < TOTAL_POSITIONS; i++) {
      newPositions[i] = this.positions[i];
    }
    return new Round8Buffer(newPositions);
  }

  /**
   * Clear all positions to 0
   */
  clear(): void {
    for (let i = 0; i < TOTAL_POSITIONS; i++) {
      this.positions[i] = 0;
    }
  }
}

/**
 * Rotation Access Operations
 * Pure columnar stacking - direct array notation
 */
export const RotationOperations = {
  /**
   * Extract 3-bit rotation value (0-7) using columnar stacking
   */
  extractRotation(buffer: Round8Buffer, rotationNum: number): number {
    const positions = buffer.getPositions();
    const startPos = getRotationStartPosition(rotationNum);

    // Read 3 positions directly (columnar stacking)
    const bit2 = positions[startPos];     // High bit
    const bit1 = positions[startPos + 1]; // Mid bit
    const bit0 = positions[startPos + 2]; // Low bit

    // Combine into 0-7 value
    return (bit2 << 2) | (bit1 << 1) | bit0;
  },

  /**
   * Write 3-bit rotation value (0-7) using columnar stacking
   */
  writeRotation(buffer: Round8Buffer, rotationNum: number, value: number): void {
    if (value < 0 || value > 7) {
      throw new Round8Error(
        Round8ErrorCode.INVALID_DIGIT,
        `Rotation value must be 0-7, got ${value}`
      );
    }

    const positions = buffer.getPositions();
    const startPos = getRotationStartPosition(rotationNum);

    // Write 3 positions directly (columnar stacking)
    positions[startPos] = (value >> 2) & 1;     // High bit
    positions[startPos + 1] = (value >> 1) & 1; // Mid bit
    positions[startPos + 2] = value & 1;        // Low bit
  },

  /**
   * Get sign bit (position 0)
   */
  getSignBit(buffer: Round8Buffer): 0 | 1 {
    return buffer.getPositions()[SIGN_POSITION] as 0 | 1;
  },

  /**
   * Set sign bit (position 0)
   */
  setSignBit(buffer: Round8Buffer, value: 0 | 1): void {
    buffer.getPositions()[SIGN_POSITION] = value;
  },

  /**
   * Get rotation value by rotation number (0-20)
   */
  getRotationValue(buffer: Round8Buffer, rotationNum: number): number {
    if (rotationNum < 0 || rotationNum > SINGLE_ROTATION_INDEX) {
      throw new Round8Error(
        Round8ErrorCode.INVALID_DIGIT,
        `Rotation number must be 0-${SINGLE_ROTATION_INDEX}, got ${rotationNum}`
      );
    }
    return this.extractRotation(buffer, rotationNum);
  },

  /**
   * Set rotation value by rotation number (0-20)
   */
  setRotationValue(buffer: Round8Buffer, rotationNum: number, value: number): void {
    if (rotationNum < 0 || rotationNum > SINGLE_ROTATION_INDEX) {
      throw new Round8Error(
        Round8ErrorCode.INVALID_DIGIT,
        `Rotation number must be 0-${SINGLE_ROTATION_INDEX}, got ${rotationNum}`
      );
    }
    this.writeRotation(buffer, rotationNum, value);
  },
};

/**
 * Special Pattern Operations
 * Handle zero and negative-one reserved patterns
 */
export const SpecialPatterns = {
  /**
   * Check if buffer is zero (all positions = 0)
   */
  isBufferZero(buffer: Round8Buffer): boolean {
    const positions = buffer.getPositions();
    for (let i = 0; i < TOTAL_POSITIONS; i++) {
      if (positions[i] !== 0) {
        return false;
      }
    }
    return true;
  },

  /**
   * Check if buffer is negative one
   * Pattern: Sign=0, all magnitude positions=1
   */
  isBufferNegativeOne(buffer: Round8Buffer): boolean {
    const positions = buffer.getPositions();

    // Sign must be 0
    if (positions[SIGN_POSITION] !== 0) {
      return false;
    }

    // All magnitude positions must be 1
    for (let i = MAGNITUDE_START; i <= MAGNITUDE_END; i++) {
      if (positions[i] !== 1) {
        return false;
      }
    }

    return true;
  },

  /**
   * Encode zero to buffer (all positions = 0)
   */
  encodeZeroToBuffer(buffer: Round8Buffer): void {
    buffer.clear();
  },

  /**
   * Encode negative one to buffer
   * Pattern: Sign=0, all magnitude=1
   */
  encodeNegativeOneToBuffer(buffer: Round8Buffer): void {
    const positions = buffer.getPositions();

    positions[SIGN_POSITION] = 0; // Negative sign

    // Set all magnitude positions to 1
    for (let i = MAGNITUDE_START; i <= MAGNITUDE_END; i++) {
      positions[i] = 1;
    }
  },

  /**
   * Encode maximum positive to buffer
   * Pattern: Sign=1, all magnitude=1
   */
  encodeMaxPositiveToBuffer(buffer: Round8Buffer): void {
    const positions = buffer.getPositions();

    positions[SIGN_POSITION] = 1; // Positive sign

    // Set all magnitude positions to 1
    for (let i = MAGNITUDE_START; i <= MAGNITUDE_END; i++) {
      positions[i] = 1;
    }
  },
};

/**
 * Buffer Increment Operations
 * Core Round8 counting algorithm with rotation-wise carry
 */
export const IncrementOperations = {
};

/**
 * Conversion Operations
 * Transform between decimal, buffer, and Round8 string representations
 */
export const ConversionOperations = {
  /**
   * Convert decimal to Round8 buffer
   */
  decimalToRound8Buffer(decimal: number): Round8Buffer {
    // Validate safe integer
    if (!Number.isSafeInteger(decimal)) {
      throw new Round8Error(
        Round8ErrorCode.OUT_OF_SAFE_INTEGER_RANGE,
        `Decimal ${decimal} exceeds safe integer range`
      );
    }

    const buffer = new Round8Buffer();

    // Handle zero
    if (decimal === 0) {
      SpecialPatterns.encodeZeroToBuffer(buffer);
      return buffer;
    }

    // Handle negative one
    if (decimal === -1) {
      SpecialPatterns.encodeNegativeOneToBuffer(buffer);
      return buffer;
    }

    // Determine sign
    const isNegative = decimal < 0;
    let workingValue = BigInt(Math.abs(decimal));

    // Set sign bit
    RotationOperations.setSignBit(buffer, isNegative ? 0 : 1);

    // Extract cycle values (base-72 digits)
    const cycleValues: number[] = [];
    for (let cycle = 0; cycle < TOTAL_CYCLES + 1; cycle++) {
      const cycleValue = Number(workingValue % 72n);
      cycleValues.push(cycleValue);
      workingValue = workingValue / 72n;
    }

    // Convert cycle values to rotation values
    for (let cycle = 0; cycle < TOTAL_CYCLES; cycle++) {
      const cycleValue = cycleValues[cycle]; // 0-71 for paired cycles
      const lowRotation = cycle * 2;
      const highRotation = cycle * 2 + 1;

      // Split cycle value into two rotations (each 0-7)
      // cycleValue = highRotation * 8 + lowRotation
      const lowValue = cycleValue % 8;
      const highValue = Math.floor(cycleValue / 8);

      RotationOperations.setRotationValue(buffer, lowRotation, lowValue);
      RotationOperations.setRotationValue(buffer, highRotation, highValue);
    }

    // Single rotation 20
    RotationOperations.setRotationValue(buffer, SINGLE_ROTATION_INDEX, cycleValues[TOTAL_CYCLES]);

    return buffer;
  },

  /**
   * Convert Round8 buffer to decimal
   */
  round8BufferToDecimal(buffer: Round8Buffer): number {
    // Check special patterns
    if (SpecialPatterns.isBufferZero(buffer)) {
      return 0;
    }

    if (SpecialPatterns.isBufferNegativeOne(buffer)) {
      return -1;
    }

    // Read sign
    const sign = RotationOperations.getSignBit(buffer);
    const isNegative = sign === 0;

    // Calculate decimal value
    let decimal = 0n;

    // Cycles 0-9 (paired rotations)
    for (let cycle = 0; cycle < TOTAL_CYCLES; cycle++) {
      const lowRotation = cycle * 2;
      const highRotation = cycle * 2 + 1;

      const lowValue = RotationOperations.getRotationValue(buffer, lowRotation);
      const highValue = RotationOperations.getRotationValue(buffer, highRotation);

      // Combine into cycle value
      const cycleValue = BigInt(highValue * 8 + lowValue);

      // Add to decimal
      decimal += cycleValue * CYCLE_VALUES[cycle];
    }

    // Single rotation 20
    const rotation20Value = BigInt(RotationOperations.getRotationValue(buffer, SINGLE_ROTATION_INDEX));
    decimal += rotation20Value * CYCLE_VALUES[TOTAL_CYCLES];

    // Apply sign
    const result = isNegative ? -Number(decimal) : Number(decimal);

    // Validate safe integer
    if (!Number.isSafeInteger(result)) {
      throw new Round8Error(
        Round8ErrorCode.OUT_OF_SAFE_INTEGER_RANGE,
        `Result ${result} exceeds safe integer range`
      );
    }

    return result;
  },

  /**
   * Convert buffer to Round8 string
   * Display uses digits 1-8, internal uses 0-7
   */
  round8BufferToString(buffer: Round8Buffer, includeCommas = true): string {
    // Special patterns
    if (SpecialPatterns.isBufferZero(buffer)) {
      return '0';
    }

    if (SpecialPatterns.isBufferNegativeOne(buffer)) {
      return '-1';
    }

    // Read sign
    const sign = RotationOperations.getSignBit(buffer);
    const isNegative = sign === 0;

    // Read rotations from left to right (rotation 20 down to 0)
    const digits: string[] = [];
    let leadingZeros = true;

    for (let rotationNum = SINGLE_ROTATION_INDEX; rotationNum >= 0; rotationNum--) {
      const internalValue = RotationOperations.getRotationValue(buffer, rotationNum);
      const displayDigit = internalValue + 1; // Map 0-7 → 1-8

      // Skip leading 1s (represent 0 in that rotation)
      if (leadingZeros && displayDigit === 1) {
        continue;
      }

      leadingZeros = false;
      digits.push(displayDigit.toString());
    }

    // If all rotations were 0
    if (digits.length === 0) {
      digits.push('1');
    }

    // Join digits
    let result = digits.join('');

    // Add commas every 4 digits from right
    if (includeCommas && result.length > 4) {
      result = FormattingOperations.formatRound8WithCommas(result);
    }

    // Add sign
    if (isNegative) {
      result = '-' + result;
    }

    return result;
  },

  /**
   * Convert Round8 string to buffer
   */
  round8StringToBuffer(round8String: string): Round8Buffer {
    // Validate format
    if (!ValidationOperations.validateRound8String(round8String)) {
      throw new Round8Error(
        Round8ErrorCode.INVALID_STRING,
        `Invalid Round8 string: ${round8String}`
      );
    }

    const buffer = new Round8Buffer();

    // Parse sign
    const isNegative = round8String.startsWith('-');
    let workingString = isNegative ? round8String.slice(1) : round8String;

    // Remove commas
    workingString = FormattingOperations.removeCommasFromRound8(workingString);

    // Handle special values
    if (workingString === '0') {
      SpecialPatterns.encodeZeroToBuffer(buffer);
      return buffer;
    }

    // Set sign
    RotationOperations.setSignBit(buffer, isNegative ? 0 : 1);

    // Parse digits from right to left
    const digits = workingString.split('').reverse();

    for (let i = 0; i < digits.length && i <= SINGLE_ROTATION_INDEX; i++) {
      const displayDigit = parseInt(digits[i], 10);
      const internalValue = displayDigit - 1; // Map 1-8 → 0-7
      RotationOperations.setRotationValue(buffer, i, internalValue);
    }

    return buffer;
  },

  /**
   * Shorthand: decimal to string
   */
  decimalToRound8String(decimal: number, includeCommas = true): string {
    const buffer = this.decimalToRound8Buffer(decimal);
    return this.round8BufferToString(buffer, includeCommas);
  },

  /**
   * Shorthand: string to decimal
   */
  round8StringToDecimal(round8String: string): number {
    const buffer = this.round8StringToBuffer(round8String);
    return this.round8BufferToDecimal(buffer);
  },
};

/**
 * Arithmetic Operations
 * Add, subtract, multiply, divide using rotation-wise operations
 */
export const ArithmeticOperations = {
  /**
   * Add two buffers using Round8 carry logic
   */
  addRound8Buffers(a: Round8Buffer, b: Round8Buffer): Round8Buffer {
    const signA = RotationOperations.getSignBit(a);
    const signB = RotationOperations.getSignBit(b);

    // If signs differ, convert to subtraction
    if (signA !== signB) {
      const decimalA = ConversionOperations.round8BufferToDecimal(a);
      const decimalB = ConversionOperations.round8BufferToDecimal(b);
      return ConversionOperations.decimalToRound8Buffer(decimalA + decimalB);
    }

    // Same sign: rotation-wise addition
    const result = new Round8Buffer();
    RotationOperations.setSignBit(result, signA);

    let carry = 0;

    for (let rotationNum = 0; rotationNum <= SINGLE_ROTATION_INDEX; rotationNum++) {
      const valueA = RotationOperations.getRotationValue(a, rotationNum);
      const valueB = RotationOperations.getRotationValue(b, rotationNum);
      const sum = valueA + valueB + carry;

      if (sum < 8) {
        RotationOperations.setRotationValue(result, rotationNum, sum);
        carry = 0;
      } else {
        // sum >= 8, Round8 carry
        RotationOperations.setRotationValue(result, rotationNum, sum - 7);
        carry = 1;
      }
    }

    // Check overflow
    if (carry !== 0) {
      throw new Round8Error(
        Round8ErrorCode.OUT_OF_SAFE_INTEGER_RANGE,
        'Addition overflow'
      );
    }

    return result;
  },

  /**
   * Subtract b from a
   */
  subtractRound8Buffers(a: Round8Buffer, b: Round8Buffer): Round8Buffer {
    // For v0.0.1: use decimal conversion
    const decimalA = ConversionOperations.round8BufferToDecimal(a);
    const decimalB = ConversionOperations.round8BufferToDecimal(b);
    return ConversionOperations.decimalToRound8Buffer(decimalA - decimalB);
  },

  /**
   * Multiply two buffers
   */
  multiplyRound8Buffers(a: Round8Buffer, b: Round8Buffer): Round8Buffer {
    // Handle zero
    if (SpecialPatterns.isBufferZero(a) || SpecialPatterns.isBufferZero(b)) {
      return new Round8Buffer();
    }

    // For v0.0.1: use decimal conversion
    const decimalA = ConversionOperations.round8BufferToDecimal(a);
    const decimalB = ConversionOperations.round8BufferToDecimal(b);
    const result = decimalA * decimalB;

    if (!Number.isSafeInteger(result)) {
      throw new Round8Error(
        Round8ErrorCode.OUT_OF_SAFE_INTEGER_RANGE,
        'Multiplication overflow'
      );
    }

    return ConversionOperations.decimalToRound8Buffer(result);
  },

  /**
   * Divide dividend by divisor (floor division)
   */
  divideRound8Buffers(dividend: Round8Buffer, divisor: Round8Buffer): Round8Buffer {
    // Check division by zero
    if (SpecialPatterns.isBufferZero(divisor)) {
      throw new Round8Error(
        Round8ErrorCode.DIVISION_BY_ZERO,
        'Division by zero'
      );
    }

    // For v0.0.1: use decimal conversion
    const decimalDividend = ConversionOperations.round8BufferToDecimal(dividend);
    const decimalDivisor = ConversionOperations.round8BufferToDecimal(divisor);
    const result = Math.floor(decimalDividend / decimalDivisor);

    return ConversionOperations.decimalToRound8Buffer(result);
  },
};

/**
 * Comparison Operations
 * Compare buffers for ordering
 */
export const ComparisonOperations = {
  /**
   * Compare two buffers
   * @returns -1 if a < b, 0 if a === b, 1 if a > b
   */
  compareRound8Buffers(a: Round8Buffer, b: Round8Buffer): -1 | 0 | 1 {
    const signA = RotationOperations.getSignBit(a);
    const signB = RotationOperations.getSignBit(b);

    // Different signs
    if (signA !== signB) {
      return signA > signB ? 1 : -1; // Sign=1 (positive) > Sign=0 (negative)
    }

    // Same sign, compare rotations from left to right
    for (let rotationNum = SINGLE_ROTATION_INDEX; rotationNum >= 0; rotationNum--) {
      const valueA = RotationOperations.getRotationValue(a, rotationNum);
      const valueB = RotationOperations.getRotationValue(b, rotationNum);

      if (valueA !== valueB) {
        if (signA === 1) {
          // Positive: larger rotation = larger value
          return valueA > valueB ? 1 : -1;
        } else {
          // Negative: larger rotation = smaller value (more negative)
          return valueA > valueB ? -1 : 1;
        }
      }
    }

    // All rotations equal
    return 0;
  },

  /**
   * Check equality
   */
  equalsRound8Buffers(a: Round8Buffer, b: Round8Buffer): boolean {
    return this.compareRound8Buffers(a, b) === 0;
  },
};

/**
 * Validation Operations
 * Input validation for Round8 strings and values
 */
export const ValidationOperations = {
  /**
   * Validate Round8 string format
   */
  validateRound8String(input: string): boolean {
    // Allow: optional minus, digits 1-8, optional commas
    const pattern = /^-?[1-8](,[1-8]{4})*[1-8]*$|^-?[1-8]+$/;
    return pattern.test(input) || input === '0' || input === '-1';
  },

  /**
   * Validate Round8 display digit (1-8)
   */
  validateRound8Digit(digit: number): boolean {
    return Number.isInteger(digit) && digit >= 1 && digit <= 8;
  },

  /**
   * Assert valid digit
   */
  assertValidRound8Digit(digit: number): void {
    if (!this.validateRound8Digit(digit)) {
      throw new Round8Error(
        Round8ErrorCode.INVALID_DIGIT,
        `Invalid Round8 digit: ${digit}. Must be 1-8.`
      );
    }
  },

  /**
   * Check if decimal is safe integer
   */
  isDecimalSafeInteger(decimal: number): boolean {
    return Number.isSafeInteger(decimal);
  },
};

/**
 * Formatting Operations
 * Handle comma insertion/removal for readability
 */
export const FormattingOperations = {
  /**
   * Add commas to Round8 string for readability
   */
  formatRound8WithCommas(raw: string): string {
    // Add commas every 4 digits from right
    const reversed = raw.split('').reverse();
    const withCommas: string[] = [];

    for (let i = 0; i < reversed.length; i++) {
      if (i > 0 && i % 4 === 0) {
        withCommas.push(',');
      }
      withCommas.push(reversed[i]);
    }

    return withCommas.reverse().join('');
  },

  /**
   * Remove commas from Round8 string
   */
  removeCommasFromRound8(formatted: string): string {
    return formatted.replace(/,/g, '');
  },
};

/**
 * Constants
 * Mathematical and encoding constants for Round8
 */
export const Round8Constants = {
  // Base and structure
  BASE: 72,
  COLUMN_COUNT: 11,
  ROTATION_COUNT: 21,
  CYCLE_COUNT: 10,
  POSITIONS_PER_ROTATION: 3,
  POSITIONS_PER_CYCLE: 6,
  MAGNITUDE_POSITIONS: 63,
  SIGN_POSITION_INDEX: 0,
  TOTAL_POSITIONS: 64,

  // Rotation value ranges
  MAX_ROTATION_VALUE: 8, // Internal (1-8)
  MIN_ROTATION_VALUE: 1, // Internal (1-8)
  MAX_DISPLAY_DIGIT: 8,  // Display (1-8)
  MIN_DISPLAY_DIGIT: 1,  // Display (1-8),

  // Inverted sign convention
  SIGN_NEGATIVE_TRAJECTORY: 0,
  SIGN_POSITIVE_TRAJECTORY: 1,

  // Special patterns (binary literals)
  ZERO_PATTERN: 0b0000000000000000000000000000000000000000000000000000000000000000n,
  NEGATIVE_ONE_PATTERN: 0b0111111111111111111111111111111111111111111111111111111111111111n,
  MAX_POSITIVE_PATTERN: 0b1111111111111111111111111111111111111111111111111111111111111111n,

  // JavaScript interop limits
  JS_MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  JS_MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,

  // Theoretical Round8 range
  THEORETICAL_MAX: 72n ** 11n,
  TOTAL_DISTINCT_VALUES: 2n * (72n ** 11n) - 1n,

  // v0.0.1 Implementation limit
  IMPLEMENTATION_LIMIT: Number.MAX_SAFE_INTEGER,

  // Formatting
  COMMA_CHARACTER: ',',
  ZERO_STRING: '0',
  NEGATIVE_SIGN: '-',
  POSITIVE_SIGN: '+',
};

/**
 * Legacy Compatibility - BitOperations namespace
 * Maps to RotationOperations for backward compatibility
 */
export const BitOperations = {
  extractThreeBits(view: DataView, bitOffset: number): number {
    throw new Round8Error(
      Round8ErrorCode.INVALID_STRING,
      'BitOperations deprecated - use RotationOperations instead. Round8 uses Rotations, not bits/bytes.'
    );
  },

  writeThreeBits(view: DataView, bitOffset: number, value: number): void {
    throw new Round8Error(
      Round8ErrorCode.INVALID_STRING,
      'BitOperations deprecated - use RotationOperations instead. Round8 uses Rotations, not bits/bytes.'
    );
  },

  getSignBit: RotationOperations.getSignBit,
  setSignBit: RotationOperations.setSignBit,
  getPositionValue: RotationOperations.getRotationValue,
  setPositionValue: RotationOperations.setRotationValue,
};